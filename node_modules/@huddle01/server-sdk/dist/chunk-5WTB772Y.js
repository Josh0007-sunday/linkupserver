import { getInfraClient } from './chunk-UUMIXEWS.js';
import { mainLogger } from './chunk-76CTSAYR.js';
import { SDK_VERSION } from './chunk-BIMOF3EO.js';
import { z } from 'zod';

var RecordingTypeSchema = z.enum(["recording", "livestream"]);
z.object({
  sessionId: z.string().optional(),
  limit: z.number().min(1).max(20).optional(),
  cursor: z.number().optional()
});
z.object({
  status: z.enum(["ongoing", "stopped"]),
  startTime: z.number().optional(),
  type: RecordingTypeSchema.optional()
});
var logger = mainLogger.createSubLogger("recorder");
var Recorder = class {
  projectId;
  apiKey;
  infraClient;
  url = "https://apira.huddle01.media/api/v1";
  constructor(projectId, apiKey) {
    logger.info("\u{1F514} Initializing Recorder SDK");
    this.projectId = projectId;
    this.apiKey = apiKey;
    this.infraClient = getInfraClient({
      apiKey
    });
  }
  async startRecording(data) {
    if (data.options?.audioOnly)
      throw new Error(
        "Cannot record with both audioOnly and videoOnly options"
      );
    const res = await fetch(`${this.url}/recording/start`, {
      body: JSON.stringify({
        roomId: data.roomId,
        token: data.token,
        layout: data.layout ?? "grid",
        projectId: this.projectId,
        customLayoutUrl: data.customLayoutUrl,
        customStorage: data.customStorage,
        watermark: data.watermark,
        pinToIpfs: data.pinToIpfs,
        options: data.options,
        type: RecordingTypeSchema.Enum.recording
      }),
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey,
        "x-sdk-version": SDK_VERSION
      }
    });
    const d = await res.json();
    return d;
  }
  async startLivestream(data) {
    const res = await fetch(`${this.url}/recording/start`, {
      body: JSON.stringify({
        roomId: data.roomId,
        token: data.token,
        layout: "grid",
        projectId: this.projectId,
        rtmpUrls: data.rtmpUrls,
        customLayoutUrl: data.customLayoutUrl,
        customStorage: data.customStorage,
        type: RecordingTypeSchema.Enum.livestream,
        recordLivestream: data.recordLivestream
      }),
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey,
        "x-sdk-version": SDK_VERSION
      }
    });
    const d = await res.json();
    return d;
  }
  async stop(data) {
    const res = await fetch(`${this.url}/recording/stop`, {
      body: JSON.stringify({
        roomId: data.roomId
      }),
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey,
        "x-sdk-version": SDK_VERSION
      }
    });
    const d = await res.json();
    return d;
  }
  async getRecordingStatus(data) {
    const queryParams = new URLSearchParams({
      roomId: data.roomId
    }).toString();
    const res = await fetch(`${this.url}/recording/status?${queryParams}`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey,
        "x-sdk-version": SDK_VERSION
      }
    });
    const d = await res.json();
    return d;
  }
  getRecordings = async (data) => {
    try {
      const params = {
        limit: data?.limit?.toString() ?? "10",
        cursor: data?.cursor?.toString() ?? "0"
      };
      if (data?.sessionId) {
        params.sessionId = data.sessionId;
      }
      const resp = await this.infraClient.api.v2.sdk.recordings.$get({
        query: params
      });
      const recordingData = await resp.json();
      return { data: recordingData };
    } catch (error) {
      logger.error("\u274C Error in fetching recordings", error);
      return {
        data: null,
        error: new Error("\u274C Error in fetching recordings")
      };
    }
  };
};

export { Recorder, RecordingTypeSchema };
